# 概念

是根据键（Key）而直接访问在内存存储位置的数据结构。

从根本上来说，一个哈希表包含一个数组，通过特殊的关键码(也就是key)来访问数组中的元素。哈希表的主要思想是通过一个哈希函数， 把关键码映射的位置去寻找存放值的地方 ，读取的时候也是直接通过关键码来找到位置并存进去。

最直接的例子就是字典，例如下面的字典图，如果我们要找 “啊” 这个字，只要根据拼音 “a” 去查找拼音索引，查找 “a” 在字典中的位置 “啊”，这个过程就是哈希函数的作用，用公式来表达就是：f(key)，而这样的函数所建立的表就是哈希表。比起数组和链表查找元素时需要遍历整个集合的情况来说，哈希表明显方便和效率的多。

![img](https://img.yluchao.cn/typora/0431176c61e30d32d3d5aa7491545172.png)

# 几个概念

## 1. 装载因子

​    为了定量的表示 `Hash`表中空位的多少，定义**装载因子**：

```javascript
Hash表的装载因子 = 填入表中的元素个数 / Hash表的长度
```

​    由公式可知，装载因子越大，说明 `Hash`表中的元素越多，空闲位置越少，散列冲突的概率越大，散列表的性能就会下降。

## 2. 散列函数

散列函数是从关键字到地址区间的映像

# 常见的哈希算法

哈希表的组成取决于哈希算法，也就是哈希函数的构成，下面列举几种常见的哈希算法。

1） 直接定址法

- 取关键字或关键字的某个线性函数值为散列地址。
- 即 f(key) = key 或 f(key) = a*key + b，其中a和b为常数。

2） 除留余数法

- 取关键字被某个不大于散列表长度 m 的数 p 求余，得到的作为散列地址。
- 即 f(key) = key % p, p < m。这是最为常见的一种哈希算法。

3） 数字分析法

- 当关键字的位数大于地址的位数，对关键字的各位分布进行分析，选出分布均匀的任意几位作为散列地址。
- 仅适用于所有关键字都已知的情况下，根据实际应用确定要选取的部分，尽量避免发生冲突。

4） 平方取中法

- 先计算出关键字值的平方，然后取平方值中间几位作为散列地址。
- 随机分布的关键字，得到的散列地址也是随机分布的。

5） 随机数法

- 选择一个随机函数，把关键字的随机函数值作为它的哈希值。
- 通常当关键字的长度不等时用这种方法。

# 哈希冲突

哈希表因为其本身的结构使得查找对应的值变得方便快捷，但也带来了一些问题，以上面的字典图为例，key中的一个拼音对应一个字，那如果字典中有两个字的拼音相同呢？例如，我们要查找 “按” 这个字，根据字母拼音就会跳到 “安” 的位置，这就是典型的哈希冲突问题。这个时候用公式表达就是：

```
key1 ≠  key2  ， f(key1) = f(key2)
```

一般来说，哈希冲突是无法避免的，如果要完全避免的话，那么就只能一个字典对应一个值的地址，也就是一个字就有一个索引 (**安** 和 **按**就是两个索引)，这样一来，空间就会增大，甚至内存溢出。

# 哈希冲突的解决办法

常见的哈希冲突解决办法有两种，**开放地址法**和**链地址法**。

### 一、开放地址法

开发地址法的做法是，当冲突发生时，使用某种探测算法在散列表中寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到。按照探测序列的方法，一般将开放地址法区分为线性探查法、二次探查法、双重散列法等。

这里为了更好的展示三种方法的效果，我们用以一个模为8的哈希表为例，采用除留余数法，往表中插入三个关键字分别为26，35，36的记录，分别除8取模后，在表中的位置如下：
![img](https://img.yluchao.cn/typora/a31c6ab7688a0739c461ca054feb6092.png)

这个时候插入42，那么正常应该在地址为2的位置里，但因为关键字30已经占据了位置，所以就需要解决这个地址冲突的情况，接下来就介绍三种探测方法的原理，并展示效果图。

1） 线性探查法：

fi=(f(key)+i) ％ m ，0 ≤ i ≤ m-1

探查时从地址 d 开始，首先探查 T[d]，然后依次探查 T[d+1]，…，直到 T[m-1]，此后又循环到 T[0]，T[1]，…，直到探查到有空余的地址或者到 T[d-1]为止。

插入42时，探查到地址2的位置已经被占据，接着下一个地址3，地址4，直到空位置的地址5，所以39应放入地址为5的位置。

缺点：需要不断处理冲突，无论是存入还是査找效率都会大大降低。
![img](https://img.yluchao.cn/typora/8c29015d51c1f669f3b092c3203e2748.png)

2） 二次探查法

fi=(f(key)+di) ％ m，0 ≤ i ≤ m-1

探查时从地址 d 开始，首先探查 T[d]，然后依次探查 T[d+di]，di 为增量序列12，-12，22，-22，……，q2，-q2 且q≤1/2 (m-1) ,直到探查到 有空余地址或者到 T[d-1]为止。

缺点：无法探查到整个散列空间。

所以插入42时，探查到地址2被占据，就会探查T[2+1^2]也就是地址3的位置，被占据后接着探查到地址7，然后插入。
![img](https://img.yluchao.cn/typora/04af5af979c2746accba5f9e114014ed.png)

3） 双哈希函数探测法

fi=(f(key)+i*g(key)) % m (i=1，2，……，m-1)

其中，f(key) 和 g(key) 是两个不同的哈希函数，m为哈希表的长度

步骤：

双哈希函数探测法，先用第一个函数 **f(key)** 对关键码计算哈希地址，一旦产生地址冲突，再用第二个函数 **g(key)** 确定移动的步长因子，最后通过步长因子序列由探测函数寻找空的哈希地址。

比如，f(key)=a 时产生地址冲突，就计算g(key)=b，则探测的地址序列为 f1=(a+b) mod m，f2=(a+2b) mod m，……，fm-1=(a+(m-1)b) % m，假设 b 为 3，那么关键字42应放在 “5” 的位置。
![img](https://img.yluchao.cn/typora/811483d1a8ac6c12aa983d1a32a0a202.png)

### 二、链表法

散列表中，每个“桶（bucket）”都会对应一个条链表，在查找时先听过hash(key)找到位置，然后遍历链表找到对应元素

插入数据：当插入的时候，我们需要通过散列函数计算出对应的散列槽位，将其插入到对应的链表中即可，所以插入的时间复杂度为O(1)。
查找或删除数据：当查找、删除一个元素时，通过散列函数计算对应的槽，然后遍历链表查找或删除。对于散列比较均匀的散列函数，链表的节点个数k=n/m，其中n表示散列表中数据的个数，m表示散列表中槽的个数，所以是时间复杂度为O(k)。

![img](https://img.yluchao.cn/typora/a8290829afca7ef2efbd0fdf9d570dc3.png)



## 解决冲突方法对比

| 方法       | 优点                                                         | 缺点                                                         | 适用场景                                                     |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 开放寻址法 | 1、数据存储在数组，可以有效利用CPU缓存加速查询速度；<br>2、序列化简单 | 1、删除需要特殊标记已删除数据；<br />2. 所有数据存储在一个数组，发生冲突时，解决的代价更高，造成装载因子不能太大，使得更加浪费内存空间 | 1. 数据量小<br>2. 装载因子小                                 |
| 链表法     | 1、内存利用率高，需要时再申请；<br>2. 对大装载因子容忍度高，可大于1 | 因为链表需要存储指针，存储指针需要消耗内存，不适合小对象存储（万一存储数据没有指针大？？？多浪费）<br>链表节点不是连续空间，因此CPU缓存不友好 | 1. 存储大对象、大数据量的散列表<br>2. 支持更多优化策略，如红黑树代替链表。 |



# 哈希表性能

 哈希表的特性决定了其高效的性能，大多数情况下查找或者插入元素的时间复杂度可以达到O(1)， 时间主要花在计算hash值上， 然而也有一些极端的情况，最坏的就是hash值全都映射在同一个地址上，这样哈希表就会退化成链表，例如下面的图片：
![img](https://img2018.cnblogs.com/blog/1478697/201810/1478697-20181024201749156-1898841778.png)
当hash表变成图2的情况时，时间复杂度会变为O(n)，效率瞬间低下，所以，设计一个好的哈希表尤其重要，如HashMap在jdk1.8后引入的红黑树结构就很好的解决了这种情况。

