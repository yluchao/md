### 1 什么是跳表

- 跳表结合了链表和二分查找的思想
- 由原始链表和一些通过“跳跃”生成的链表组成
- 第0层是原始链表，越上层“跳跃”的越高，元素越少
- 上层链表是下层链表的子序列
- 查找时从顶层向下，不断缩小搜索范围

### 2 跳表的特性

1. 一个跳表应该有几个层（level）组成；
    通常是10-20层，leveldb中默认为12层。
2. 跳表的第0层包含所有的元素；
    且节点值是有序的。
3. 每一层都是一个有序的链表；
    层数越高应越稀疏，这样在高层次中能'跳过’许多的不符合条件的数据。
4. 如果元素x出现在第i层，则所有比i小的层都包含x；
5. 每个节点包含key及其对应的value和一个指向该节点第n层的下个节点的指针数组
    x->next[level]表示第level层的x的下一个节点

### 3. 跳表的查询过程

查询的第一个比vx大的节点的前一个值，看是否相等。相等则存在，否则查找下一层，直到层数为0。

以已有数据13、22、75、80、99为例

![clipboard.png](http://img.yluchao.cn/typora/eb674749bc823022034bc27db34ba8af.png) 

从最高层（此处为2）开始

1、level2找到结点Node75小于80，且level2.Node75->next 大于80，则进入level1查找(此处已经跳过了13~75中间的结点（22),

2、level1.Node75 < 80 < level1.Node75->next，进入level0

3、level0.Node75->next 等于80，找到结点

### 4. 插入过程

假设插入一新键值key，值为84，level为当前层

![clipboard.png](http://img.yluchao.cn/typora/879caa6e338c4b66edad8fc679383557.png) 

1、从最高层开始找到每一层比84大的节点的前一个值，存入prev[level]。

这里

prev[2] = leve2.Node75

prev[1] = leve1.Node75

prev[0] = level0.Node80

2、初始化一个新的节点84
3、为x**随机选择一个高度h**,这里选2

​	随机高度，是类似抛硬币的随机法，例如：

```c
int random_level()  
{  
    K = 1;  
  
    while (random(0,1))  
        K++;  
  
    return K;  
}  
```

4、x->next[0..h-1] = prev[0..h-1]->next
5、prev[0..h-1]->next[0..h-1] = x

（步骤4、5为链表插入结点的操作）

### 5. 删除操作

删除操作类似于插入操作，包含如下3步：1、查找到需要删除的结点 2、删除结点 3、调整指针