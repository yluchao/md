![image-20210221210059309](http://img.yluchao.cn/typora/4bfb98eb083704a30bbafae2e936e714.png)

## 字符串

字符串的存储结构就字符数组

与其它编程语言或其它键值存储提供的字符串非常相似，键(key)------值(value) (字符串格式),字符串拥有一些操作命令，如：get set del 还有一些比如自增或自减操作等等。redis是使用C语言开发，但C中并没有字符串类型，只能使用指针或符数组的形式表示一个字符串，所以redis设计了一种简单动态字符串(SDS[Simple Dynamic String])作为底实现：

定义SDS对象，此对象中包含三个属性：

1. len buf中已经占有的长度(表示此字符串的实际长度)
2. free buf中未使用的缓冲区长度
3. buf[] 实际保存字符串数据的地方

所以取字符串的长度的时间复杂度为O(1)，另，buf[]中依然采用了C语言的以\0结尾可以直接使用C语言的部分标准C字符串库函数。

空间分配原则：当len小于IMB（1024*1024）时增加字符串分配空间大小为原来的2倍，当len大于等于1M时每次分配 额外多分配1M的空间。

由此可以得出以下特性：

1. redis为字符分配空间的次数是小于等于字符串的长度N，而原C语言中的分配原则必为N。降低了分配次数提高了追加速度，代价就是多占用一些内存空间，且这些空间不会自动释放。
2. 二进制安全的
3. 高效的计算字符串长度(时间复杂度为O(1))
4. 高效的追加字符串操作。

### redis为什么要实现sds（https://zhuanlan.zhihu.com/p/269496479）

Redis是使用C语言开发的，在C语言中没有字符串这种数据类型，字符串大都是通过字符数组实现的，但是使用字符数组有以下不足：

1. 字符数组的长度都是固定，容易发生空指针
2. 获取字符数组的长度的时候需要便利数组，时间复杂度较高
3. 字符数组长度发生改变之后需要重新分配内存
4. 使用\0表示结尾，在存储二进制的时候就会出现问题。

所以Redis就自己实现了SDS来解决上面的问题，下面是SDS相对的一些优点：

1. 长度达到一定标准会有相应的扩容。从而解决内存溢出的问题。
2. 在SDS的内部定义了字符串的长度，使用时可以直接获取。从而解决获取长度时间复杂度高的问题。
3. SDS是空间预分配，惰性释放内存的。从而减少分配内存的次数
4. SDS根据长度判断结束的位置。从而解决二进制不安全的问题。

### 应用场景

	1. 单值存储
	2. 对象存储（json）
	3. 分布式锁（setnx）
	4. 计数器（inc）
	5. 分布式系统全局序列号

## 列表 

列表的数据存储结构有两种，一种是压缩列表，另外一种是双向循环列表 

当列表中存储的数据量比较小的时候，列表就可以采用压缩列表的方式实现。具体需要同时满足下面两个条件：

- 列表中保存的单个数据（有可能是字符串类型的）小于 64 字节；
- 列表中数据个数少于 512 个。

### 应用场景

1. 队列
2. 栈

## 字典 （hash）

存储字典的数据结构有两种，一种是压缩列表，另外一种是散列表。散列表采用了渐进式扩容缩容策略。 

同样，只有当存储的数据量比较小的情况下，Redis 才使用压缩列表来实现字典类型。具体需要满足两个条件：

- 字典中保存的键和值的大小都要小于 64 字节；
- 字典中键值对的个数要小于 512 个。

### 应用场景

​	1. 购物车

## 集合 

集合的存储数据结构有两种，一种是基于有序数组，另一种是基于散列表

Redis 采用有序数组，来实现集合这种数据类型的条件：

- 存储的数据都是整数；
- 存储的数据元素个数不超过 512 个。

疑问：**为啥不用压缩列表**。

整数集合intset的数据结构，与ziplist类似，都是使用一段连续分配的内存来存储数据，其特殊之处在于整数集合中存储的是按照升序排列的整数数据。

当使用整数集合作为底层实现的set，如果向其中插入一个字符串数据的话，或者其中元素个数超过上限，那么就需要将其底层实现方式转化为哈希表。

其实来说整数集合intset本质上与ziplist的设计思路都是一致的。

从定义和存储内容来看，ziplist 更复杂，而 inset 就更简单一些，如果 set 类型存了字符串，就直接变成了 hash 结构；那么如果 set 类型在实际生产环境中，更多的使用在存储整数方面的话，就可以解释说是为了提高效率且节约存储空间；

## 有序集合

有序集合的存储方式有两种，一种是压缩列表，一种是跳表

使用压缩列表来实现有序集合的前提，有这样两个：

- 所有数据的大小都要小于 64 字节；
- 元素个数要小于 128 个。
