# 一、什么是IO

我们都知道unix世界里、一切皆文件、而文件是什么呢？文件就是一串二进制流而已、不管socket、还是FIFO、管道、终端、对我们来说、一切都是文件、一切都是流、在信息交换的过程中、我们都是对这些流进行数据的收发操作、简称为I/O操作(input and output)、往流中读出数据、系统调用read、写入数据、系统调用write、不过话说回来了、计算机里有这么多的流、我怎么知道要操作哪个流呢？做到这个的就是文件描述符、即通常所说的fd、一个fd就是一个整数、所以对这个整数的操作、就是对这个文件（流）的操作、我们创建一个socket、通过系统调用会返回一个文件描述符、那么剩下对socket的操作就会转化为对这个描述符的操作、不能不说这又是一种分层和抽象的思想。

# 二、IO交互

通常用户进程中的一个完整IO分为两个阶段：

![img](http://img.yluchao.cn/typora/958fd5c8adf16b4224d2bc882163e843.png) 

内核空间中存放的是内核代码和数据、而进程的用户空间中存放的是用户程序的代码和数据、不管是内核空间还是用户空间、它们都处于虚拟空间中、Linux使用两级保护机制：0级供内核使用、3级供用户程序使用；

操作系统和驱动程序运行在内核空间、应用程序运行在用户空间、两者不能简单地使用指针传递数据、因为Linux使用的虚拟内存机制、其必须通过系统调用请求kernel来协助完成IO动作、内核会为每个IO设备维护一个缓冲区、用户空间的数据可能被换出、当内核空 间使用用户空间指针时、对应的数据可能不在内存中

对于一个输入操作来说、进程IO系统调用后、内核会先看缓冲区中有没有相应的缓存数据、没有的话再到设备中读取、因为设备IO一般速度较慢、需要等待、内核缓冲区有数据则直接复制到进程空间；

所以、对于一个网络输入操作通常包括两个不同阶段：

（1）等待网络数据到达网卡 –&gt; 读取到内核缓冲区

（2）从内核缓冲区复制数据 –&gt; 用户空间

IO有内存IO、网络IO和磁盘IO三种、通常我们说的IO指的是后两者

# 三、常见的IO模型

《UNIX网络编程》说得很清楚、5种IO模型分别是**阻塞IO模型**、**非阻塞IO模型**、**IO复用模型**、**信号驱动的IO模型**、**异步IO模型**，前4种为同步IO操作、只有异步IO模型是异步IO操作、请仔细阅读IO交互便于理解IO模型

## 3.1 阻塞IO（blocking I/O）

A拿着一支鱼竿在河边钓鱼，并且一直在鱼竿前等，在等的时候不做其他的事情，十分专心。只有鱼上钩的时，才结束掉等的动作，把鱼钓上来。

在内核将数据准备好之前，系统调用会一直等待所有的套接字，默认的是阻塞方式。 

![img](http://img.yluchao.cn/typora/8ed223814a4b8ed0ad7131934335b778.png) 

这个模型是我们最常见的，程序调用和我们编写的基本程序是一致的。

```c
fd=connect();
write(fd);
read(fd);
close(fd);
```

程序的read必须在write之后执行，当write阻塞住了，read就不能执行下去，一直处于等待状态。

## 3.2 非阻塞IO（noblocking I/O）

B也在河边钓鱼，但是B不想将自己的所有时间都花费在钓鱼上，在等鱼上钩这个时间段中，B也在做其他的事情（一会看看书，一会读读报纸，一会又去看其他人的钓鱼等），但B在做这些事情的时候，每隔一个固定的时间检查鱼是否上钩。一旦检查到有鱼上钩，就停下手中的事情，把鱼钓上来。

![img](http://img.yluchao.cn/typora/3a0fb63ca6199bee260902f506c11916.png) 

其实，B在检查鱼竿是否有鱼，是一个轮询的过程。

每次客户询问内核是否有数据准备好，即文件描述符缓冲区是否就绪。当有数据报准备好时，就进行拷贝数据报的操作。当没有数据报准备好时，也不阻塞程序，内核直接返回未准备就绪的信号，等待用户程序的下一个轮寻。

但是，轮寻对于CPU来说是较大的浪费，一般只有在特定的场景下才使用。

## 3.3 信号驱动IO（signal blocking I/O）

C也在河边钓鱼，但与A、B不同的是，C比较聪明，他给鱼竿上挂一个铃铛，当有鱼上钩的时候，这个铃铛就会被碰响，C就会将鱼钓上来。

![img](http://img.yluchao.cn/typora/b2245c3dad2ce6667ec5f8fa9a762384.png)

信号驱动IO模型，应用进程告诉内核：当数据报准备好的时候，给我发送一个信号，对SIGIO信号进行捕捉，并且调用我的信号处理函数来获取数据报。

## 3.4 IO多路复用（I/O multiplexing）

D同样也在河边钓鱼，但是D生活水平比较好，D拿了很多的鱼竿，一次性有很多鱼竿在等，D不断的查看每个鱼竿是否有鱼上钩。增加了效率，减少了等待的时间。

![img](http://img.yluchao.cn/typora/d9b118e2c923f7f2a5a26425ba1373f9.png) 

IO多路转接是多了一个select函数，select函数有一个参数是文件描述符集合，对这些文件描述符进行循环监听，当某个文件描述符就绪时，就对这个文件描述符进行处理。

其中，select只负责等，recvfrom只负责拷贝。
IO多路转接是属于阻塞IO，但可以对多个文件描述符进行阻塞监听，所以效率较阻塞IO的高。

其中除了select外还有 poll和epoll两种模型具体参考https://www.cnblogs.com/aspirant/p/9166944.html

## 3.5 异步IO（asynchronous I/O）

E也想钓鱼，但E有事情，于是他雇来了F，让F帮他等待鱼上钩，一旦有鱼上钩，F就打电话给E，E就会将鱼钓上去。

![img](http://img.yluchao.cn/typora/7627e2854f802057b85ca4025bbed8ab.png) 

当应用程序调用aio_read时，内核一方面去取数据报内容返回，另一方面将程序控制权还给应用进程，应用进程继续处理其他事情，是一种非阻塞的状态。

当内核中有数据报就绪时，由内核将数据报拷贝到应用程序中，返回aio_read中定义好的函数处理程序。

很少有Linux系统支持，Windows的IOCP就是该模型。



可以看出，阻塞程度：阻塞IO>非阻塞IO>多路转接IO>信号驱动IO>异步IO，效率是由低到高的。

### 参考文献：

https://www.cnblogs.com/yanguhung/p/10145755.html

https://zhuanlan.zhihu.com/p/115912936
