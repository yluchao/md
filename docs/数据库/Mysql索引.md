# 前言

假如你去面试，面试官让你聊一下对索引的理解，然而你对索引的理解仅限于，检索数据就是快，是一种数据结构这个层面，那你就只能回家等通知了。

## MySQL索引到底是什么

相信大多数伙伴都买过技术类的书籍，看完没看完不知道，但是目录肯定看的次数最多。

看目录有没有自己目前的痛点，如果有就会根据目录对应的页码用最快的速度翻阅到相应内容位置。

那么在MySQL中同样也是这样的一个道理，MySQL的索引就是存储引擎为了快速找到数据的一种`数据结构`

同样在MySQL索引中又分了几种类型，分别为B-tree索引、哈希索引、空间索引、全文索引。

下文所有内容均在Innodb的基础上讨论。

## 为什么要使用索引

索引可以`加快数据检索速度`，这也是使用的索引的最主要原因。

索引本身具有顺序性，在进行范围查询时，获取的数据已经排好了序，从而`避免服务器再次排序和建立临时表的问题`。

索引的底层实现本身具有顺序性，通过磁盘预读使得在磁盘上对数据的访问大致呈顺序的寻址，也就是`将随机的I/O变为顺序I/O`。

**任何事物都存在双面性，既然能提供性能的提升，自然在其它方面也会付出额外的代价。**

索引是跟数据共存，因此会占用额外的存储空间。

索引创建和维护需要时间成本，这个成本随着数据量的增大而增大。

索引创建会降低数据的增、删、改的性能，因为在修改数据的同时还需要修改索引数据。

# Hash索引

先来创建一个hash索引`alter table user add index hash_gender using hash(gender);`

存储引擎使用的是innodb。

![hash索引](http://img.yluchao.cn/typora/673614f1f6144e2b7b5cf7fb69fab5ac.png)

hash索引

会发现name的索引类型还是为Btree，在innodb上创建哈希索引，被称之为伪哈希索引，和真正的哈希索引不是一回事的，这点一定要明白。

在Innodb存储引擎中有一个特殊的功能叫做，自适应哈希索引，当索引值被使用的非常频繁时，它会在内存中基于BTree索引之上再创建一个哈希索引，那么就拥有了哈希索引的一些特点，比如快速查找

哈希索引就是基于哈希表实现的，假设对 name 建立了哈希索引，则查找过程如下图所示，哈希表是根据键值对进行访问的数据结构，它让检索的数据经过哈希函数映射到散列表的对应位置，查找效率非常高。

![哈希索引数据结构](http://img.yluchao.cn/typora/f178742db3853af2fdffe3ad286b6cc4.png)

哈希索引数据结构

哈希索引存储的是哈希值和行指针，没有存储key值、字段值，但哈希索引多数是在内存完成的，检索数据是非常快的，所以对性能影响不大。

哈希索引不是按照索引值排序的，所以也就无法排序。

哈希索引只支持等值操作，不支持范围查找，在MySQL中只能只用 =、in 、<>

哈希索引在任何时候都不能避免表扫描

哈希索引在遇到大量哈希冲突时，存储引擎必须遍历链表的所有行指针，逐行比较。

# B+Tree跟BTree区别

- B+Tree叶子节点上存储的是全量数据(key+data)，而非叶子节点只存储key
- B+Tree在同样的深度下存储的数据是远远大于BTree的。
- B+Tree每个叶子节点都有指向下一个叶子节点的链接。这样的好处在于，我们可以从任意一个叶子节点开始遍历，获取接下来所有的数据。

# B+Tree适合做索引的原因

B+Tree树非叶子节点只存储key值，因此相对于BTree节点可以存储更多的数据，每次读入内存的key值就更多，相对来说`I/O就降低`

B+Tree树查询效率稳定，任何数据的查找都是必须从叶子节点到非叶子节点，所以说每个数据查找的效率几乎都是相同的。

B+Tree树的叶子节点存储的是全量数据，并且是有序的，所以说只需要遍历叶子节点就可以对所有的key进行扫描，在范围查找时效率更高。

以上就是关于Innodb存储引擎为什么使用B+Tree作为索引的解析。

# 聚簇索引、非聚簇索引区别

- 聚簇索引：就是按照每张表的主键构造一颗B+树，同时叶子节点中存放的就是整张表的行记录数据，也将聚集索引的叶子节点称为数据页。这个特性决定了索引组织表中数据也是索引的一部分，每张表只能拥有一个聚簇索引。

- 非聚簇索引（二级索引）：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行。

那么如何区分聚簇索引和非聚簇索引呢！

首先看一下Innodb引擎下，创建表生成的文件，可以看到有俩个ibd文件。

![数据表文件](http://img.yluchao.cn/typora/8fce240fd859c3677a6108714b834135.png)

数据表文件

看到这里不知道大家有没有疑问，为什么看有的文章中也会有frm文件呢！但是在这里怎么没有呢！

原因是在MySQL8.0之后将源数据都存储到了表空间中，所以也就不存在frm文件喽！

都知道这个idb文件会存储数据信息和索引信息。

那再来看一下Myisam存储引擎创建表生产的文件。

![myisam存储引擎创建表生成的文件](http://img.yluchao.cn/typora/0ab5429b24078e845adc8c2e5f7efb59.png)

myisam存储引擎创建表生成的文件

从图中可以看到创建一个表会生成三个文件，扩展名分别为MYD、MYI、sdi。

MYD：是表数据文件(保存数据的文件）

MYI ：是表索引文件(保存索引的文件)

**`那么就可以得出一个结论`**

只要数据跟索引存储在一个文件里，那就是聚簇索引，否则就是非聚簇索引。

这个时候就会有人问了，表中有主键的时候，idb文件中存储的是主键+数据，那么当没有设置主键时怎么办呢！

```
记住这一句话，在Innodb中，数据插入时必须跟一个索引值进行绑定，如果没有主键那就选择唯一索引，如果没有唯一索引就会选择一个6Byte的rowid。
```

# 表中存在多个索引怎么存储的

看了上文的解释，有没有产生过一丝疑问，在Innodb存储引擎下，如果存在多个索引，是不是会产生多个idb文件。

```
在Innodb中数据只会保存一份，如果有多个索引，会维护多个B+Tree
```

例如：表字段 id，name，age，sex。

id设置为主键索引（聚簇索引），name设置为普通索引，那么数据到底会存储几份呢！

不管一个表中设置多少个索引，数据只会存储一份，但是这张表会维护多个B+Tree。

按照这个案例中id为主键索引，name为普通索引，那么在这张表中就会维护俩颗B+Tree。

id主键索引跟数据存储在一起，name索引所在的B+Tree中叶子节点存储的是主键id的值。

对应的图就是以下俩幅图，可以好好的看一下。

![主键索引对应的B+Tree](http://img.yluchao.cn/typora/8d8cab4a59e93920a2a25aa606c106ce.jpeg)

主键索引对应的B+Tree

![name索引对应的B+Tree](http://img.yluchao.cn/typora/e0a7d359b161b5a0d34d3f3b4d3efda8.jpeg)

name索引对应的B+Tree

最后给大家总结一个点：**在Innodb中，一定有聚簇索引，其它索引都是非聚簇索引**。

这里简单提一下myisam中只有非聚簇索引。

## 联合索引

​		单列索引其实也可以看做联合索引，索引列为1的联合索引，从下图就可以看出联合索引的底层存储跟单列索引时类似的，区别在于联合索引是每个树节点中包含多个索引值，在通过索引查找记录时，会先将联合索引中第一个索引列与节点中第一个索引值进行匹配，匹配成功接着匹配第二个索引列和索引值，直到联合索引的所有索引列都匹配完；如果过程中出现某一个索引列与节点相应位置的索引值不匹配的情况，则无需再匹配节点中剩余索引列，前往下一个节点。

![联合索引示意图](https://img.yluchao.cn/typora/bc945f64bd7133d77f91ba83ed9bd55e.jpeg)



## 前缀索引

前缀索引就是基于原始索引字段，截取前面指定的字符个数或者字节数来做的索引。如果一个字段内容的前边的n位信息已经足够标识当前的字段内容，就可以把字段的前n位获得出来并创建索引，该索引占据空间更小、运行速度更快.

```sql
alter table  表名  add  key  (字段(前n位位数));
```

#### 到底前几位可以唯一标识字段的内容？

获取制作前缀索引的n的信息：

1. 去除字段重复内容并计算总数目.
2. 取字段的前(n)1、2、3.....位不重复的信息并计算总数目，n从1开始不断累加，直到总数目 与 ①计算的总数目相等，此时n就是我们设计前缀索引的数字n信息.

mysql中截取字段的前n位信息，使用函数left(字段,长度).例如截取前5位信息： left(字段,5).

#### 制作前缀索引

计算全部字段不重复记录的总条数:

```
select count(distinct 字段) from 表;
```

计算前n位不重复记录的总条数，n从1开始累加:

```
select count(distinct left(字段,n)) from 表;
```

比较两个统计的数据是否一致,如果一致就取N的值作为前缀索引. 前缀索引比普通索引速度要快很多.

# 索引的几个技术名词

## 1. 回表

还是用上边的案例，id为主键索引，name为普通索引。

此时查询语句为`select id,name,age from table where name = 'kaka'`

那么这条语句会先在name的这颗B+Tree中寻找到主键id，然后在根据主键id的索引获取到数据并且返回。

`其实这个过程就是从非聚簇索引跳转到聚簇索引中查找数据，被称为回表`,也就是说当你查询的字段为非聚簇索引，但是非聚簇索引中没有将需要查询的字段全部包含就是回表。

在这个案例中，非聚簇索引name的叶子节点只有id，并没有age，所以会跳转到聚簇索引中，根据id在查询整条记录返回需要的字段数据。

## 2. 覆盖索引

![img](http://img.yluchao.cn/typora/035ffc987d2e982b830b02ecbd054738.png)

MySQL官网，类似的说法出现在explain查询计划优化章节，即==explain的输出结果Extra字段为**Using index**时，能够触发索引覆盖==。

![img](http://img.yluchao.cn/typora/bc09fac0d640ac0b1ef4815d0042fdf7.png)

不管是SQL-Server官网，还是MySQL官网，都表达了：==只需要在一棵索引树上就能获取SQL所需的所有列数据，无需回表，速度更快==。

 如何实现索引覆盖呢？

常见的方法是：将被查询的字段，建立到联合索引里去。

仍是之前中的例子：

```sql
create table user (
    id int primary key,
    name varchar(20),
    sex varchar(5),
    index(name)
)engine=innodb;
```

第一个SQL语句：　　

 ![img](http://img.yluchao.cn/typora/d626cc6c51e81419916bb9569ac286fa.png)

```sql
select id,name from user where name='shenjian';
```

能够命中name索引，索引叶子节点存储了主键id，通过name的索引树即可获取id和name，无需回表，符合索引覆盖，效率较高。

画外音，Extra：**Using index**。

第二个SQL语句：         

![img](https://img2018.cnblogs.com/blog/885859/201907/885859-20190729185053070-767208274.png)

```
select id,name,sex from user where name='shenjian';
```

能够命中name索引，索引叶子节点存储了主键id，但sex字段必须回表查询才能获取到，不符合索引覆盖，需要再次通过id值扫码聚集索引获取sex字段，效率会降低。

画外音，Extra：**Using index condition**。

如果把(name)单列索引升级为联合索引(name, sex)就不同了。

```
create table user (
    id int primary key,
    name varchar(20),
    sex varchar(5),
    index(name, sex)
)engine=innodb;
```

![img](https://img2018.cnblogs.com/blog/885859/201907/885859-20190729185140811-2063536201.png)

可以看到：

```sql
select id,name ... where name='shenjian';
 
select id,name,sex ... where name='shenjian';
```

都能够命中索引覆盖，无需回表。

画外音，Extra：**Using index**。

## 3. 最左匹配

最左匹配原则是在组合索引中存在的。

还是用之前表信息：表字段 id，name，age，sex。

此时给name，age设置成组合索引。

以下语句中那个不符合最左侧原则。

```sql
select * from table where name = ? and age = ?

select * from table where name = ?

select * from table where age = ?

select * from table where age= ? and name= ?
```

可以自行做一下测验哈！是只有第三条语句不会用到索引，其它的三条语句都会符合最左侧原则。

## 4. 索引下推

- 索引下推（index condition pushdown ）简称ICP，在Mysql5.6的版本上推出，用于优化查询。
- 在不使用ICP的情况下，在使用非主键索引（又叫普通索引或者二级索引）进行查询时，存储引擎通过索引检索到数据，然后返回给MySQL服务器，服务器然后判断数据是否符合条件 。
- 在使用ICP的情况下，如果存在某些被索引的列的判断条件时，MySQL服务器将这一部分判断条件传递给存储引擎，然后由存储引擎通过判断索引是否符合MySQL服务器传递的条件，只有当索引符合条件时才会将数据检索出来返回给MySQL服务器 。
- 索引条件下推优化可以减少存储引擎查询基础表的次数，也可以减少MySQL服务器从存储引擎接收数据的次数。

- 在开始之前先先准备一张用户表(user)，其中主要几个字段有：id、name、age、address。建立联合索引（name，age）。
- 假设有一个需求，要求匹配姓名第一个为陈的所有用户，sql语句如下：

```sql
SELECT * from user where  name like '陈%'
```

- 根据 "最佳左前缀" 的原则，这里使用了联合索引（name，age）进行了查询，性能要比全表扫描肯定要高。
- 问题来了，如果有其他的条件呢？假设又有一个需求，要求匹配姓名第一个字为陈，年龄为20岁的用户，此时的sql语句如下：

```sql
SELECT * from user where  name like '陈%' and age=20
```

- 这条sql语句应该如何执行呢？下面对Mysql5.6之前版本和之后版本进行分析。

### **Mysql5.6之前的版本**

- 5.6之前的版本是没有索引下推这个优化的，因此执行的过程如下图：



![img](http://img.yluchao.cn/typora/93a71a67ed8c794818df23c8ca524568.jpeg)





- 会忽略age这个字段，直接通过name进行查询，在(name,age)这课树上查找到了两个结果，id分别为2,1，然后拿着取到的id值一次次的回表查询，因此这个过程需要**回表两次**。



### **Mysql5.6及之后版本**

- 5.6版本添加了索引下推这个优化，执行的过程如下图：



![img](http://img.yluchao.cn/typora/278033a4f7ac6d4d4c6594ad4c2cc25b.jpeg)



- InnoDB并没有忽略age这个字段，而是在索引内部就判断了age是否等于20，对于不等于20的记录直接跳过，因此在(name,age)这棵索引树中只匹配到了一个记录，此时拿着这个id去主键索引树中回表查询全部数据，这个过程只需要回表一次。
