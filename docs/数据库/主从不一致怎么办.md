**问：常见的数据库集群架构如何？**

**答**：一主多从，主从同步，读写分离。

![img](https://img.yluchao.cn/typora/1e3f008faaace1c425a7a49804d0a29f.webp)

如上图：

（1）一个主库提供写服务

（2）多个从库提供读服务，可以增加从库提升读性能

（3）主从之间同步数据

*画外音：任何方案不要忘了本心，加从库的本心，是提升读性能。*

 

**问：为什么会出现不一致？**

**答**：主从同步有时延，这个时延期间读从库，可能读到不一致的数据。

![img](https://img.yluchao.cn/typora/7a65c7598eef8aedfcc9d14e9b23aaa3.webp)

如上图：

（1）服务发起了一个写请求

（2）服务又发起了一个读请求，此时同步未完成，读到一个不一致的脏数据

（3）数据库主从同步最后才完成

*画外音：任何数据冗余，必将引发一致性问题。*

 

**问：如何避免这种主从延时导致的不一致？**

**答**：常见的方法有这么几种。

 

**方案一：忽略**

任何脱离业务的架构设计都是耍流氓，绝大部分业务，例如：百度搜索，淘宝订单，QQ消息，58帖子都允许短时间不一致。

*画外音：如果业务能接受，最推崇此法。*

 

如果业务能够接受，别把系统架构搞得太复杂。

 

**方案二：强制读主**

![img](https://img.yluchao.cn/typora/d1c7b3f32fc2d163e8b8391449276980.webp)

如上图：

（1）使用一个高可用主库提供数据库服务

（2）读和写都落到主库上

（3）采用缓存来提升系统读性能

这是很常见的微服务架构，可以避免数据库主从一致性问题。

 

**方案三：选择性读主**

强制读主过于粗暴，毕竟只有少量写请求，很短时间，可能读取到脏数据。

 

有没有可能实现，只有这一段时间，可能读到从库脏数据的读请求读主，平时读从呢？

 

可以利用一个缓存记录必须读主的数据。

![img](https://img.yluchao.cn/typora/5625b902013f2f02f386fc9d71a24646.webp)

如上图，当写请求发生时：

（1）写主库

（2）将哪个库，哪个表，哪个主键三个信息拼装一个key设置到cache里，这条记录的超时时间，设置为“主从同步时延”

*画外音：key的格式为“db:table:PK”，假设主从延时为1s，这个key的cache超时时间也为1s。*

 

![img](https://img.yluchao.cn/typora/e916ac6a3eff2fdce8f9b1d0fb9bd402.webp)

如上图，当读请求发生时：

这是要读哪个库，哪个表，哪个主键的数据呢，也将这三个信息拼装一个key，到cache里去查询，如果，

（1）**cache里有这个key**，说明1s内刚发生过写请求，数据库主从同步可能还没有完成，此时就应该去主库查询

（2）**cache里没有这个key**，说明最近没有发生过写请求，此时就可以去从库查询

以此，保证读到的一定不是不一致的脏数据。

**总结**

数据库主库和从库不一致，常见有这么几种优化方案：

（1）业务可以接受，系统不优化

（2）强制读主，高可用主库，用缓存提高读性能

（3）在cache里记录哪些记录发生过写请求，来路由读主还是读从